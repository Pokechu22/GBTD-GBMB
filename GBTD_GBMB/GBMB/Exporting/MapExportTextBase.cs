using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GB.Shared.GBMFile;
using System.IO;

namespace GB.GBMB.Exporting
{
	/// <summary>
	/// Base class for export fromats that are text-based.
	/// </summary>
	public abstract class MapExportTextBase : IMapExporter
	{
		/// <summary>
		/// The stream that is being written to.
		/// </summary>
		protected StreamWriter Stream { get; private set; }

		/// <summary>
		/// Text that should be put at the begining of the header block.  EG for C, "<c>/*</c>".
		/// </summary>
		protected abstract string HeaderBegin { get; }
		/// <summary>
		/// Text that should be put at the start of each line of the header block.  EG for ASM, "<c>; </c>".
		/// </summary>
		protected abstract string HeaderLine { get; }
		/// <summary>
		/// Text that should be put at the end of the header block.  EG for C, "<c>*/</c>".
		/// </summary>
		protected abstract string HeaderEnd { get; }

		/// <summary>
		/// The text that starts a block.  EG for C, "<c>{</c>".
		/// </summary>
		protected abstract string BlockBegin { get; }
		/// <summary>
		/// The text that ends a block.  EG for C, "<c>};</c>".
		/// </summary>
		protected abstract string BlockEnd { get; }

		public void Export(GBMFile file, Stream stream, String fileName) {
			using (this.Stream = new StreamWriter(stream)) {
				var mapExportSettings = file.GetObjectOfType<GBMObjectMapExportSettings>();

				WriteHeader(mapExportSettings, fileName);
				Stream.WriteLine();
				WriteSizeDefines(mapExportSettings);
				Stream.WriteLine();
				WriteMapData(file);
			}
		}

		/// <summary>
		/// Writes the header at the top that includes version information and such.
		/// </summary>
		/// <param name="settings"></param>
		/// <param name="fileName"></param>
		public void WriteHeader(GBMObjectMapExportSettings settings, String fileName) {
			//TODO handle source vs include file.
			
			Stream.WriteLine(HeaderBegin);
			Stream.WriteLine(HeaderLine + " " + Path.GetFileName(fileName).ToUpperInvariant());
			Stream.WriteLine(HeaderLine);
			Stream.WriteLine(HeaderLine + " Map Source File.");
			Stream.WriteLine(HeaderLine);
			Stream.WriteLine(HeaderLine + " Info:");
			Stream.WriteLine(HeaderLine + "   Section       : {0}", settings.SectionName);
			Stream.WriteLine(HeaderLine + "   Bank          : {0}", settings.Bank);
			Stream.WriteLine(HeaderLine + "   Map size      : {0} x {1}", settings.Master.Width, settings.Master.Height);
			Stream.WriteLine(HeaderLine + "   Tile set      : {0}", Path.GetFileName(settings.Master.TileFile));
			Stream.WriteLine(HeaderLine + "   Plane count   : {0}", settings.PlaneCount.GetDisplayName());
			Stream.WriteLine(HeaderLine + "   Plane order   : {0}", settings.PlaneOrder.GetDisplayName());
			Stream.WriteLine(HeaderLine + "   Tile offset   : {0}", settings.TileOffset);
			Stream.WriteLine(HeaderLine + "   Split data    : {0}", (settings.Split ? "Yes" : "No"));
			Stream.WriteLine(HeaderLine + "   Block size    : {0}", settings.SplitSize);
			Stream.WriteLine(HeaderLine);
			Stream.WriteLine(HeaderLine + " This file was generated by GBMB v1.8"); //TODO actual version.
			Stream.WriteLine(HeaderEnd);
		}

		/// <summary>
		/// Writes the defines that state the width, height, and bank.
		/// </summary>
		public abstract void WriteSizeDefines(GBMObjectMapExportSettings settings);

		/// <summary>
		/// Writes the entire map's data.
		/// </summary>
		public void WriteMapData(GBMFile gbmFile) {
			var settings = gbmFile.GetObjectOfType<GBMObjectMapExportSettings>();

			//TODO this doesn't handle planes... or anything really.
			//Currently, asume "Tiles are continuous".

			int planeCount = settings.PlaneCount.GetNumberOfPlanes();

			//Build the byte array data of data.
			Byte[] dataTemp = new Byte[settings.Master.Width * settings.Master.Height * planeCount];

			if (settings.MapLayout == MapLayout.Rows) {
				for (int y = 0; y < settings.Master.Height; y++) {
					for (int x = 0; x < settings.Master.Width; x++) {
						Byte[] tileData = MapDataMaker.GetBytesForTile(gbmFile, x, y, settings.PlaneCount);
						for (int i = 0; i < planeCount; i++) {
							dataTemp[(((y * settings.Master.Height) + x) * planeCount) + i] = tileData[i];
						}
					}
				}
			} else if (settings.MapLayout == MapLayout.Columns) {
				for (int x = 0; x < settings.Master.Width; x++) {
					for (int y = 0; y < settings.Master.Height; y++) {
						Byte[] tileData = MapDataMaker.GetBytesForTile(gbmFile, x, y, settings.PlaneCount);
						for (int i = 0; i < planeCount; i++) {
							dataTemp[(((y * settings.Master.Height) + x) * planeCount) + i] = tileData[i];
						}
					}
				}
			}

			int numberOfSplitBlocks = (int)Math.Ceiling((double)(settings.Master.Width * settings.Master.Height * planeCount) / settings.SplitSize);

			Byte[][] data = new Byte[numberOfSplitBlocks][];
			for (uint i = 0; i < numberOfSplitBlocks; i++) {
				uint length = settings.SplitSize;
				if (length > dataTemp.Length - (settings.SplitSize * i)) {
					length = (uint)(dataTemp.Length - (settings.SplitSize * i));
				}
				data[i] = new Byte[length];
				Array.Copy(dataTemp, settings.SplitSize * i, data[i], 0, length);
			}

			for (int i = 0; i < data.Length; i++) {
				WritePlaneLabel(settings, 0, i);
				WriteData(data[i]);
			}
		}

		/// <summary>
		/// Writes the label for the specified plane and block.
		/// </summary>
		/// <param name="settings"></param>
		/// <param name="plane"></param>
		/// <param name="block"></param>
		public abstract void WritePlaneLabel(GBMObjectMapExportSettings settings, int plane, int block);

		/// <summary>
		/// Writes a section of data -- a plane or a block.
		/// </summary>
		/// <param name="bytes"></param>
		public virtual void WriteData(Byte[] bytes) {
			//The number of values to write each line.
			const int DATA_PER_LINE = 10;

			Stream.Write(BlockBegin);
			int position = 0;
			while (position < bytes.Length) {
				WriteDataLine(bytes, ref position, DATA_PER_LINE);
			}
			Stream.Write(BlockEnd);

			Stream.WriteLine();
		}

		/// <summary>
		/// Writes a line of data.
		/// </summary>
		/// <param name="bytes">The data to write.</param>
		/// <param name="position">The position in the array to start at.  Will be incremented.</param>
		/// <param name="count">The number of bytes to write.</param>
		public abstract void WriteDataLine(Byte[] bytes, ref int position, int count);
	}
}
