using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using GB.Shared.GBMFile;
using System.IO;

namespace GB.GBMB.Exporting
{
	/// <summary>
	/// Base class for export fromats that are text-based.
	/// </summary>
	public abstract class MapExportTextBase : IMapExporter
	{
		/// <summary>
		/// The stream that is being written to.
		/// </summary>
		protected StreamWriter Stream { get; private set; }

		/// <summary>
		/// Text that should be put at the begining of the header block.  EG for C, "<c>/*</c>".
		/// </summary>
		protected abstract string HeaderBegin { get; }
		/// <summary>
		/// Text that should be put at the start of each line of the header block.  EG for ASM, "<c>; </c>".
		/// </summary>
		protected abstract string HeaderLine { get; }
		/// <summary>
		/// Text that should be put at the end of the header block.  EG for C, "<c>*/</c>".
		/// </summary>
		protected abstract string HeaderEnd { get; }

		public void Export(GBMFile file, Stream stream, String fileName) {
			using (this.Stream = new StreamWriter(stream)) {
				var mapExportSettings = file.GetObjectOfType<GBMObjectMapExportSettings>();

				WriteHeader(mapExportSettings, fileName);
				Stream.WriteLine();
				WriteSizeDefines();
			}
		}

		/// <summary>
		/// Writes the header at the top that includes version information and such.
		/// </summary>
		/// <param name="settings"></param>
		/// <param name="fileName"></param>
		public void WriteHeader(GBMObjectMapExportSettings settings, String fileName) {
			//TODO handle source vs include file.
			
			Stream.WriteLine(HeaderBegin);
			Stream.WriteLine(HeaderLine + " " + Path.GetFileName(fileName).ToUpperInvariant());
			Stream.WriteLine(HeaderLine);
			Stream.WriteLine(HeaderLine + " Map Source File.");
			Stream.WriteLine(HeaderLine);
			Stream.WriteLine(HeaderLine + " Info:");
			Stream.WriteLine(HeaderLine + "   Section       : {0}", settings.SectionName);
			Stream.WriteLine(HeaderLine + "   Bank          : {0}", settings.Bank);
			Stream.WriteLine(HeaderLine + "   Map size      : {0} x {1}", settings.Master.Width, settings.Master.Height);
			Stream.WriteLine(HeaderLine + "   Tile set      : {0}", Path.GetFileName(settings.Master.TileFile));
			Stream.WriteLine(HeaderLine + "   Plane count   : {0}", PlaneCountToString(settings.PlaneCount));
			Stream.WriteLine(HeaderLine + "   Plane order   : {0}", PlaneOrderToString(settings.PlaneOrder));
			Stream.WriteLine(HeaderLine + "   Tile offset   : {0}", settings.TileOffset);
			Stream.WriteLine(HeaderLine + "   Split data    : {0}", (settings.Split ? "Yes" : "No"));
			Stream.WriteLine(HeaderLine + "   Block size    : {0}", settings.SplitSize);
			Stream.WriteLine(HeaderLine);
			Stream.WriteLine(HeaderLine + " This file was generated by GBMB v1.8"); //TODO actual version.
			Stream.WriteLine(HeaderEnd);
		}

		/// <summary>
		/// Converts a planeCount value to a representitive string.
		/// TODO: When there's an enum, put this in an extension method.
		/// </summary>
		private string PlaneCountToString(UInt16 planeCount) {
			switch (planeCount) {
			case 0: return "0.5 plane (4 bits)";
			case 1: return "1 plane (8 bits)";
			case 2: return "2 planes (16 bits)";
			case 3: return "3 planes (24 bits)";
			case 4: return "4 planes (32 bits)";
			default: throw new ArgumentOutOfRangeException("planeCount", planeCount, "Plane count is not in the valid range!");
			}
		}

		/// <summary>
		/// Converts a planeOrder value to a representitive string.
		/// TODO: When there's an enum, put this in an extension method.
		/// </summary>
		private string PlaneOrderToString(UInt16 planeOrder) {
			switch (planeOrder) {
			case 0: return "Tiles are continues";
			case 1: return "Planes are continues";
			default: throw new ArgumentOutOfRangeException("planeOrder", planeOrder, "Plane order is not in the valid range!");
			}
		}

		/// <summary>
		/// Writes the defines that state the width, height, and bank.
		/// </summary>
		public abstract void WriteSizeDefines();
	}
}
